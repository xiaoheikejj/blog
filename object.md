- 对象的定义：无序属性的集合，他的属性可以包括基本值，对象或者函数
- 自定义对象就是创建一个object的实例，对象字面量，属性在创建时带有一些特征值
- 内部才用的特性。描述了属性的基本特征。数据属性[[configurable]]，[[enumerable]],[[writable]],[[value]]
- Object.defineProperty()里面传递3个参数，第一个是所在的对象，属性的名字最后一个是描述符对象（特性）
- 一旦把属性定义为不可配置的，就不能再把它变回可配置的
- 访问器属性[[configurable]],[[enumerable]],[[get]],[[set]]
- 不能直接定义，defineProperty()来定义
- Object.defineProperties()第一个参数就是需要对其修改属性的对象，第二个是和第一个对接的属性
- Object.getOwnPropertyDescriptor()返回一个对象,
- 工厂模式解决了对象字面量的创建相似对象，无法实现识别一个对象的类型
- 构造函数模式创建原生的Object和Array 构造函数； 创建自定义构造函数可以用它的实例标记为一种特定的类型
- 每个方法在每个实例上重新创造一遍；
- 每个函数都有prototype属性;一个指针，指向一个对象，特定类型的所有实例共享的属性和方法(原型对象)
- isPrototypeOf()判断布尔值；getPrototypeOf()确定_proto_
- 原型最初只有constractor；这个属性也会被实例对象访问;属性先在实例中访问，访问不到然后访问原型对象
- 虽然实例可以访问到原型中的值，但是不能修改；
- 实例新属性屏蔽原型里面的同名属性，只是阻止，delate实例属性，原型属性还是能够被访问到
- hasOwnProperty()判断布尔值，属性在实例里返回true
- in操作符用在for in里面或者单独使用。
- 单独使用属性无论在实例和原型里都返回布尔值true
- 可枚举的属性；特性[[enumerable]]是true
- Object.keys()接受一个对象作为参数，返回一个可以枚举的属性字符串数组；如果通过实例调用，只是调用实例里面的属性
- 如果想得到所有可枚举/不可枚举的实例属性；用Object.getOwnPropertyNames()
- 构造函数的问题是方法都要在每个实例上重新创建一遍
- 所有应用都默认继承了Object；所有函数的默认原型都是Object的实例
- 默认原型都包含一个内部指针 ， 指向Object.prototype
- 构造函数继承有一个最大的好处，子类型的构造函数向超类型的构造函数传递参数
