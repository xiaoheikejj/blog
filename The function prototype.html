<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title></title>
		<style type="text/css">
		*{
			margin: 0;
			padding: 0;
			list-style: none;
		}
		.divs{
			width: 600px;
			height: 600px;
			margin: auto;
			margin-top: 50px;
			border: 1px solid greenyellow;
			background-color:rgba(100,100,100,0.1) ;
			position: fixed;
			left: 500px;
			top: 50px;
			
		}
		.divs>h3{
			text-align: center;
			line-height: 200%;
			margin-top: 50px;
			font-family: "微软雅黑";
		}
		.divs>p{
			line-height: 300%;
			color: darksalmon;
			font-family: "微软雅黑";
			text-align: center;
		}
		/*.box{
			position: relative;
		}*/
		.box>img{
			/*height: auto;*/
			width: auto;
			width: 100%;
		}			
		</style>
	</head>
	<body>
		<div id="box" class="box">
			<img src="https://image.baidu.com/search/detail?ct=503316480&z=0&ipn=d&word=%E7%99%BE%E5%BA%A6%E5%9B%BE%E7%89%87&hs=2&pn=5&spn=0&di=13274505200&pi=0&rn=1&tn=baiduimagedetail&is=0%2C0&ie=utf-8&oe=utf-8&cl=2&lm=-1&cs=2950792003%2C1243141688&os=163568690%2C4180516555&simid=3292663675%2C97291513&adpicid=0&lpn=0&ln=30&fr=ala&fm=&sme=&cg=&bdtype=0&oriquery=%E7%99%BE%E5%BA%A6%E5%9B%BE%E7%89%87&objurl=http%3A%2F%2Fe.hiphotos.baidu.com%2Flvpics%2Fh%3D800%2Fsign%3D07a3fdab6d600c33ef79d3c82a4d5134%2F8c1001e93901213fd4ce706352e736d12e2e958b.jpg&fromurl=ippr_z2C%24qAzdH3FAzdH3Fsey57_z%26e3Bkwt17_z%26e3Bv54AzdH3Frtvp6wejsAzdH3Fkauck8vn8lud1dllda18llu0&gsm=0"/>
			<div class='divs'>
				<h3>函数的原型和原型链</h3>
				<p>no1.它分为构造函数以及原型对象和实例对象</p>
				<p>no2.构造函数是new关键字后面的函数以及它的首字母必须大写</p>
				<p>no3.构造函数的特点如下：new关键字调用、this指向构造出的新对象它可以将属性和方法直接赋值给this、默认不用return返回值</p>
				<h3>原型对象和实例对象</h3>
				<p>no1.A的原型是B--那么B的原型是Object--Object的原型是null</p>
				<p>no2._ _proto_ _说的是原型指针、prototype说的是原型对象</p>
				<p></p>
			</div>
		</div>
	</body>
</html>
Object.prototype的原型是null，null没有任何属性，原型链到此为止
原型链的作用是读取一个对象属性时，JS引擎先找它本身的属性，找不到就找原型，找不到就原型的原型，直到最顶层的Object.prototype还没有返回undefined
如果对象本身的属性和原型的属性重名，优先确定自己的属性
constractor可以被所有实例对象继承
instanceof判断一个对象在它的原型链中是否存在一个构造函数的prototype属性，返回一个布尔值
v instanceof Ve左边是实例对象，右边是构造函数
Object.getPrototypeOf（）返回一个对象的原型
Object.setPrototypeOf（）为现有对象设置原型，返回新对象。传递两个参数，第一个现有对象，第二个原型对象
Object.create()从一个实例对象生成另外一个实例对象
Object.prototype.isPrototypeOf()判断一个对象是否是另外一个对象的原型
_proto_是实例对象指向原型对象
获取obj的原型对象有3种方法  obj._proto_   obj.constractor.prototype   Object.getPrototypeOf(obj)
检测属性从实例对象还是原型对象获取用hasOwnProperty（）这个方法会让属性从实例获取的时候返回true，反则返回false
in操作符会通过对象让对象的给定属性时返会true，不管是这个对象来自实例还是原型
要取得对象上所有可枚举的实例属性，可以用Object.keys（），这个方法接受一个参数，返回这个参数的可枚举属性的字符串数组
想要获得所有属性，可以用Object.getOwnPropertyNames（）
instanceof来检测在一个构造函数中有没有prototype属性，返回布尔
typeof返回字符串，返会类似number，object，undefined...
构造函数模式定义实例的属性，原型模式定义实例的方法和共享属性
定义函数的方式有两种，函数声明和函数表达式
函数声明提升：可以把函数声明放在调用它的语句后面
arguments.callee指向正在执行函数的指针
匿名函数的执行环境具有全局性
this最终指向都是调用它的那个对象，object.name和（object.name）是一样的








